\documentclass[11pt]{amsart}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{url}
\usepackage[margin=1in]{geometry}

\title{Hand in Module 2}
\author{Marius Haakonsen, Ole K Larsen}

\begin{document}

\maketitle

\section{Task 1:}

\textbf{Exercise A:}\\
The both of us have already played Tetris, so we'll skip this part.  \\

\textbf{Exercise B:} \\

Implementing the function void Board::reduce() to remove the lines when completed. \\

Looping over row number i, from top to bottom. \\
\begin{verbatim}

	void Board::reduce() {
	    for(int i = 3; i < 19; i++) {

\end{verbatim}

Defining variables to use while looping over j number of columns. \\
\begin{verbatim}

	        int count = 0;
	        int tilecount = 0;
	        for(int j = 1; j < 11; j++) {
	            if (tiles[j][i] != sf::Color::Black) {
	                count++;

\end{verbatim}

If all tiles in row number 'i' is inequal to the color black, the program loops from that
row and upwards, setting the current row to be equal to the row above, giving the impression that the rows "falls down". \\
\begin{verbatim}

	              if(count == 10) {
	                  tilecount = i;
	                  for(int k = tilecount; k >= 3; k--) {
	                      for(int j = 1; j < 11; j++) {
	                          tiles[j][k] = tiles[j][k-1];
	                      }
	                  }
	                  break;
	              }
\end{verbatim}

As a little coding-exercise from out part, we also added the functionality of pressing spacebar to make the shapes move all the way down
until it intersects with other shapes. We also added a score. \\


\section{Task 2:}

\textbf{Exercise A:}\\

How was this puzzle created? \\
	Puzzling.stackexchange.com was utilized to get the correct specifications of the puzzle
	and inspiration for the statements to be made by the three people in the encounter. \\

Knight: Always tells the truth.\\
Knave: 	Always tells a lie.\\
Spy: 		Tells either the truth or a lie. \\

The puzzle involves encountering three different people, person A, B and C. \\

They all have their own statements: \\

	A: "C is the knight."\\
	B: "A is the knight."\\
	C: "B is the knave." \\

Who is the knight, who is the knave, and who is the spy among the three? \\

To reach the solution of this, the statements are put in a table. \\
\begin{tabular}{ |p{3cm}||p{3cm}|p{3cm}|p{3cm}|  }
 \hline
 \multicolumn{4}{|c|}{Knight, Knave and Spy} \\
 \hline
 Combinations & Is it true? & Would it be said? & Solution  \\ A  B  C   &   A  B  C  &   A  B  C & A  B  C \\
 \hline
	0   1   x  	& 0	0	0   & 1 0 x &  \\
	1   0   x		& 0	1	1  	& 0 0 x &  \\
	0   x   1 	&	1	0	0 	& 0 x 0 &  \\
	1   x   1  	&	0	1	0 	& 0 x 1 &  \\
	x   0   1		& 1	0	1  	& x 1 1 & 1\\
	x   1   0		& 0	0	0  	& x 0 0 &  \\
 \hline
\end{tabular}

The solution is found by asking the two following questions: 'Is it true?' and 'Would it be said?'. \\

Based on the combinations of these columns, and based on whether or not the person actually tells the truth or lies,
we find the correct combination of knight knave and spy. The next to last row is the only possible solution,
as shown by the 'x 1 1' outcome. This means that C is the knight, B is the knace and A is the spy. \\


\textbf{Exercise B:} \\
Reformulated statements, giving the same answer:\\

	A: "C may tell the truth."\\
	B: "C is not a knight."\\
	C: "B may tell a lie." \\


\begin{tabular}{ |p{3cm}||p{3cm}|p{3cm}|p{3cm}|  }
	\hline
	\multicolumn{4}{|c|}{Knight, Knave and Spy} \\
	\hline
	 Combinations & Is it true? & Would it be said? & Solution  \\ A  B  C   &   A  B  C  &   A  B  C & A  B  C \\
	\hline
	  0   1   x  	& 1	1	0   & 0 1 x	&  \\
	  1   0   x		& 1	1	1  	& 1 0 x &  \\
	  0   x   1 	&	1	0	1 	& 0 x 1	&  \\
	  1   x   1  	&	0	1	1 	& 0 x 0	&  \\
	  x   0   1		& 1	0	1  	& x 1 1	& 1\\
	  x   1   0		& 0	1	0  	& x 1 0 &  \\

	\hline
\end{tabular}


\section{Task 3:}

The forums at Stackoverflow.com was used for the solution to this task. \\

The program is written entirely using C++, as we are most familiar with this syntax.
In addition it was limited time from the lecture to when a complete
implementation using GeCode would have had to be finished, this also made it more practical to use C++. \\

\textbf{Exercise A:} \\

in 'main()' the function 'solved()' is called on the grid with an unknown number of
spots set to 0. 'clear()' returns solved as true if the position != 0. \\
'isSafe()' utilizes three functions to make sure the placement of the number i (in the loop) is
not already placed in the relevant row, column and block. A block is 1 of 9 3x3 sized grids within
the 9x9 grid. \\


\begin{verbatim}

	if (!clear(grid, r, c)) { return true; }
	for (int i = 1; i <= 9; i++) {
			if (isSafe(grid, r, c, i)) { grid[r][c] = i;
					if (solve(grid)) { return true; }
					grid[r][c] = 0;
			}


\end{verbatim}


\textbf{Exercise B:} \\

To create a new puzzle, a function that removes an unknown amount of numbers is
cast on the completed grid inside 'main()'. A random number engine is used to create a number
between 0 and 3. The function loops over every row and coloumn, and if the random number
equals 0 or 1, then the position is set to 0. \\
This function may result in an un-solveable game, but this very rarely happens. \\
The if statement can be changed to create easier or harder puzzles, depending on how many
numbers are to be removed from board. \\

\begin{verbatim}

std::uniform_int_distribution<> dist(0,4);
x = dist(generator);
if (x==0 || x==1) { grid[r][c] = 0; }

\end{verbatim}

\section{\textbf{Code Appendix:}}

\textbf{Task 1:}



\begin{verbatim}


	//Here you can make your Polyminos of choice.
	//You can draw your polyminos like this and follow the explanation in the comments below
	//	0  1  2  3	4  5
	//0
	//1    x
	//2       x  x  x
	//3    x        x
	//4
	//5

	int polyminos(int x, int y, int z) {

		switch (x) {						//x = shape number

		case 0:

			switch (y) {					//y = tile number, totalling at 6
			case 0:
				if (z == 1)					//if z = 1 means its the x coordinate of the tile you want
					return 2;				//in this case the tile (2, 0) will be coloured
				return 0;
			case 1:
				if (z == 1)					//In this case tile (2,1) will be coloured
					return 2;
				return 1;
			case 2:
				if (z == 1)
					return 2;
				return 2;
			case 3:
				if (z == 1)
					return 2;
				return 3;
			case 4:
				if (z == 1)
					return 2;
				return 4;
			case 5:
				if (z == 1)
					return 2;
				return 5;
			}								//All this sums up to a shape that is 1x6 in size, which is a straigth line
	/*


	class Shape {
	public:
	    sf::Color tiles[6][6];
	    sf::Vector2i pos;
	    // times since last downward movement
	    float time;

	    Shape();
	    // reinitialise the shape: move to top and change shape
	    void init();
	    // move downwards once per second
	    void update(float dt);
	    // render the shape
	    void draw(sf::RenderWindow& w);
	    // rotate the shape
	    void rotateLeft();
	    void rotateRight();
	};

	void Shape::rotateLeft() {
	    sf::Color tmp[6][6];
	    for(int i = 0; i < 6; i++) {
	        for(int j = 0; j < 6; j++) {
	            tmp[i][j]=tiles[j][3-i];
	        }
	    }
	    for(int i = 0; i < 6; i++) {
	        for(int j = 0; j < 6; j++) {
	            tiles[i][j]=tmp[i][j];
	        }
	    }
	}

	void Shape::rotateRight() {
	    rotateLeft();
	    rotateLeft();
	    rotateLeft();
	}

	Shape::Shape() {
	    init();
	}

	void Shape::draw(sf::RenderWindow& w) {
	    sf::CircleShape s;
	    s.setRadius(8);
	    s.setOrigin(8,8);
	    for(int i = 0; i < 6; i++) {
	        for(int j = 0; j < 6; j++) {
	            if(tiles[i][j] != sf::Color::Black) {
	                s.setFillColor(tiles[i][j]);
	                s.setPosition(sf::Vector2f(pos.x * 16 + 16 * i + 100, pos.y * 16 + 16 * j + 100));
	                w.draw(s);
	            }
	        }
	    }
	}

	void Shape::update(float dt) {
	    time += dt;
	    if(time > 1) {
	        time = 0;
	        pos.y += 1;
	    }
	}

	void Shape::init() {
	    // move to top and reset timer
	    pos.y = 0;
	    pos.x = 4;
	    time = 0.0f;

	    for(int i = 0; i < 4; i++) {
	        for(int j = 0; j < 4; j++) {
	            tiles[i][j] = sf::Color::Black;
	        }
	    }
	    switch(rand() % 8) {
	        case 0:
	            tiles[1][1] = sf::Color::Yellow;
	            tiles[1][2] = sf::Color::Yellow;
	            tiles[2][1] = sf::Color::Yellow;
	            tiles[2][2] = sf::Color::Yellow;
	            break;
	        case 1:
	            tiles[2][0] = sf::Color(255,160,0);
	            tiles[2][1] = sf::Color(255,160,0);
	            tiles[2][2] = sf::Color(255,160,0);
	            tiles[2][3] = sf::Color(255,160,0);
	            break;
	        case 2:
	            tiles[0][2] = sf::Color::Blue;
	            tiles[1][2] = sf::Color::Blue;
	            tiles[1][1] = sf::Color::Blue;
	            tiles[2][1] = sf::Color::Blue;
	            break;
	        case 3:
	            tiles[0][2] = sf::Color::Green;
	            tiles[1][2] = sf::Color::Green;
	            tiles[2][2] = sf::Color::Green;
	            tiles[1][1] = sf::Color::Green;
	            break;
	        case 4:
	            tiles[2][3] = sf::Color::White;
	            tiles[2][2] = sf::Color::White;
	            tiles[1][2] = sf::Color::White;
	            tiles[0][2] = sf::Color::White;
	            break;
	        case 5:
	            tiles[2][3] = sf::Color(4,235,250);
	            tiles[2][2] = sf::Color(4,235,250);
	            tiles[1][2] = sf::Color(4,235,250);
	            tiles[0][2] = sf::Color(4,235,250);
	            break;
	        case 6:
	            tiles[2][1] = sf::Color(255,0,255);
	            tiles[2][2] = sf::Color(255,0,255);
	            tiles[1][2] = sf::Color(255,0,255);
	            tiles[0][2] = sf::Color(255,0,255);
	            break;
	        case 7: {
	            int x=rand() % 4; int y = rand() % 4;
	            tiles[x][y] = sf::Color(75,0,150);
	            x=rand() % 4; y = rand() % 4;
	            tiles[x][y] = sf::Color(75,0,150);
	            x=rand() % 4; y = rand() % 4;
	            tiles[x][y] = sf::Color(75,0,150);
	            x=rand() % 4; y = rand() % 4;
	            tiles[x][y] = sf::Color(75,0,150);
	            break;
	        }
	    }
	}

	#include <SFML/Graphics.hpp>
	#include <cmath>
	#include <cstdlib>
	#include <iostream>
	#include <sstream>

	#ifndef _MYHEADER_H_INCLUDED
	#define _MYHEADER_H_INCLUDED
	#endif
	#include "Shape.h"

	using namespace std;

	int score;  // Defining counter for tracking score.


	class Board {
	public:
	    sf::Color tiles[12][20];

	    Board();

	    // add a shape to the board
	    void add(Shape& shape);

	    // check if a shape intersects with the board
	    bool intersect(Shape& shape);

	    // remove full lines - should be implemented by you
	    void reduce();

	    // render board
	    void draw(sf::RenderWindow& w);
	};

	void Board::reduce() {
	    for(int i = 3; i < 19; i++) {
	        int count = 0;
	        int tilecount = 0;
	        for(int j = 1; j < 11; j++) {
	            if (tiles[j][i] != sf::Color::Black) {
	                count++;
	                if(count == 10) {
	                    score = score+100;
	                    tilecount = i;
	                    for(int k = tilecount; k >= 3; k--) {
	                        for(int j = 1; j < 11; j++) {
	                            tiles[j][k] = tiles[j][k-1];
	                        }
	                    }
	                    break;
	                }
	            }
	        }
	    }
	}

	bool Board::intersect(Shape& shape) {
	    bool intersect = false;
	    for(int i = 0; i < 4; i++) {
	        for(int j = 0; j < 4; j++) {
	            if(tiles[i+shape.pos.x][j+shape.pos.y] != sf::Color::Black &&
	               shape.tiles[i][j] != sf::Color::Black)
	                intersect = true;
	        }
	    }
	    return intersect;
	}

	void Board::draw(sf::RenderWindow& w) {
	    sf::CircleShape s;
	    s.setRadius(8);
	    s.setOrigin(8,8);
	    for(int i = 0; i < 12; i++) {
	        for(int j = 0; j < 20; j++) {
	            s.setFillColor(tiles[i][j]);
	            s.setPosition(sf::Vector2f(16 * i + 100, 16*j + 100));
	            w.draw(s);
	        }
	    }
	}

	void Board::add(Shape& shape) {
	    for(int i = 0; i < 4; i++) {
	        for(int j = 0; j < 4; j++) {
	            if(shape.tiles[i][j] != sf::Color::Black) {
	                tiles[i + shape.pos.x][j + shape.pos.y] = shape.tiles[i][j];
	            }
	        }
	    }
	}

	Board::Board() {
	    // fill with black
	    for(int i = 0; i < 20; i++) {
	        for(int j = 0; j < 12; j++) {
	            tiles[j][i] = sf::Color::Black;
	        }
	    }
	    for(int i = 0; i < 12; i++) {
	        tiles[i][19] = sf::Color::Red;
	    }
	    for(int i = 0; i < 19; i++) {
	        tiles[0][i] = sf::Color::Red;
	        tiles[11][i] = sf::Color::Red;
	    }
	}

	int main() {
	    sf::RenderWindow window(sf::VideoMode(512, 512), "Tetris");

	    sf::Clock clock;
	    clock.restart();
	    Shape shape;
	    Board board;

	    sf::Text hud;
	    sf::Font font;
	    font.loadFromFile("game_over.ttf");
	    hud.setFont(font);
	    hud.setCharacterSize(65);
	    hud.setFillColor(sf::Color::White);
	    hud.setPosition(350,200);

	    while (window.isOpen())
	    {
	        // check all the window's events that were triggered since the last iteration of the loop
	        sf::Event event;

	        while (window.pollEvent(event))
	        {
	            // "close requested" event: we close the window
	            if (event.type == sf::Event::Closed || sf::Keyboard::isKeyPressed(sf::Keyboard::Q))
	                { window.close(); }

	            if (event.type == sf::Event::KeyPressed) {
	                if(event.key.code == sf::Keyboard::Left) {
	                    shape.pos.x -= 1;
	                    if (board.intersect(shape)) {
	                        shape.pos.x += 1;
	                        cout << "intersect left" << endl;
	                    }
	                }
	                if(event.key.code == sf::Keyboard::Right) {
	                    shape.pos.x += 1;
	                    if(board.intersect(shape)) {
	                        shape.pos.x -= 1;
	                        cout << "intersect right" << endl;
	                    }
	                }
	                if(event.key.code == sf::Keyboard::Down) {
	                    shape.pos.y += 1;
	                    if(board.intersect(shape)) {
	                        shape.pos.y -= 1;
	                        cout << "intersect down" << endl;
	                    }
	                }
	                if(event.key.code == sf::Keyboard::Up) {
	                    shape.rotateLeft();
	                    if(board.intersect(shape)) {
	                        shape.rotateRight();
	                        cout << "intersect rotate" << endl;
	                    }
	                }
	                if(event.key.code == sf::Keyboard::Space) {
	                    shape.pos.y += 2;
	                    if(board.intersect(shape)) {
	                        shape.pos.y -= 1;
	                        cout << "intersect down" << endl;
	                    }
	                }
	            }
	            std::stringstream ss;
	            ss << "Score: " << score;
	            hud.setString(ss.str());
	        }

	        float dt = clock.restart().asSeconds();

	        shape.update(dt);

	        if(board.intersect(shape)) {
	            shape.pos.y -= 1;
	            board.add(shape);
	            board.reduce();
	            shape.init();
	            if(board.intersect(shape)) {
	                cout << "GAME OVER" << endl;
	            }
	        }
	        window.clear(sf::Color::Black);
	        board.draw(window);
	        window.draw(hud);
	        shape.draw(window);
	        window.display();
	    }
	    return 0;
	}



\end{verbatim}


\textbf{Task 3:} \\

\begin{verbatim}

	#include <iostream>
	#include <cstdio>
	#include <cstring>
	#include <cstdlib>
	#include <random>

	const int N = 9;

	bool solve(int grid[N][N]);
	bool clear(int grid[N][N], int &row, int &col);
	bool usedRow(int grid[N][N], int row, int num);
	bool usedCol(int grid[N][N], int col, int num);
	bool usedBlock(int grid[N][N], int blockRow, int blcokCol, int num);
	bool isSafe(int grid[N][N], int row, int col, int num);
	void printGrid(int grid[N][N]);

	int main() {

	    std::random_device rand;
	    std::default_random_engine generator(rand());
	    std::uniform_int_distribution<> dist(0,4);

	    int x;
	    int grid[N][N] =
	    {
	        {2, 9, 5,   7, 4, 3,    8, 6, 1},
	        {4, 3, 1,   8, 6, 5,    9, 2, 7},
	        {8, 7, 6,   1, 9, 2,    5, 4, 3},

	        {3, 8, 7,   4, 5, 9,    2, 1, 6},
	        {6, 1, 2,   3, 8, 7,    4, 9, 5},
	        {5, 4, 9,   2, 1, 6,    7, 3, 8},

	        {7, 6, 3,   5, 2, 4,    1, 8, 9},
	        {9, 2, 8,   6, 7, 1,    3, 5, 4},
	        {1, 5, 4,   9, 3, 8,    6, 7, 2}
	    };

	        for (int r = 0; r < N; r++) {
	            for (int c = 0; c < N; c++) {
	                x = dist(generator);
	                if (x==0 || x==1) { grid[r][c] = 0; }
	            }
	        }

	    printGrid(grid); std::cout << "\n";

	    if(solve(grid)) { printGrid(grid); }
	    return 0;
	}

	bool solve(int grid[N][N]) {
	    int r, c;
	    if (!clear(grid, r, c)) { return true; }
	    for (int i = 1; i <= 9; i++) {
	        if (isSafe(grid, r, c, i)) { grid[r][c] = i;
	            if (solve(grid)) { return true; }
	            grid[r][c] = 0;
	        }
	    } return false;
	}

	bool clear(int grid[N][N], int &r, int &c) {
	    for (r = 0; r < N; r++) {
	        for (c = 0; c < N; c++) {
	            if (grid[r][c] == 0) { return true; }
	        }
	    } return false;
	}

	bool usedRow(int grid[N][N], int r, int n) {
	    for (int c = 0; c < N; c++) {
	        if (grid[r][c] == n) { return true; }
	    } return false;
	}

	bool usedCol(int grid[N][N], int c, int n) {
	    for (int r = 0; r < N; r++) {
	        if (grid[r][c] == n) { return true; }
	    } return false;
	}

	bool usedBlock(int grid[N][N], int blockRow, int blockCol, int n) {
	    for (int r = 0; r < 3; r++) {
	        for (int c = 0; c < 3; c++) {
	            if (grid[r + blockRow][c + blockCol] == n) { return true; }
	        }
	    } return false;
	}

	bool isSafe(int grid[N][N], int r, int c, int n) {
	    return !usedRow(grid, r, n) && !usedCol(grid, c, n) &&
	    !usedBlock(grid, r - r % 3 , c - c % 3, n);
	}

	void printGrid(int grid[N][N]) {
	    for (int r = 0; r < N; r++) {
	        for (int c = 0; c < N; c++) {
	            std::cout << grid[r][c] << " ";
	        } std::cout << "\n";
	    }
	}


\end{verbatim}



\end{document}
